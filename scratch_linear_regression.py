# -*- coding: utf-8 -*-
"""scratch_Linear_Regression.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1bvWNxhtOzs3ySjrBr83RvzvzT8aCiQC7
"""
class LinearRegressor:

    def __init__(self):
        pass

    def fit(self, predictor, target):
        """
        Method for fitting data between predictor and target
        """
        self.predictor = predictor
        self.target = target

        # Calculate the overall mean values
        self.mean_xi = self.predictor.mean(axis=0)
        self.mean_yi = self.target.mean()

    def coefficient(self):
        """
        Calculate the coefficients (slopes) of the linear regression model.

        Returns:
        --------
            betha_1_list : array
        Array of slope coefficients for each feature.
        """
        # Initialize list to store slopes for each feature
        self.betha_1_list = []

        for feature in self.predictor.columns:  # Iterate through each feature
            numerator = 0
            denominator = 0

            for xi, yi in zip(self.predictor[feature].values, self.target.values):
                numerator += (xi - self.mean_xi[feature]) * (yi - self.mean_yi)
                denominator += (xi - self.mean_xi[feature]) ** 2

            # Calculate beta_1 (slope) for the current feature
            betha_1 = numerator / denominator

            # Append the slope to the list
            self.betha_1_list.append(betha_1)

        return np.array(self.betha_1_list)

    def intercept(self):
        """
        Calculate the intercept of the linear regression model.

        Paramters:
        ---------
        None

        Returns:
        --------
            betha_0 : float
        Intercept value.
        """
        betha_1 = self.coefficient()

        # Calculate beta_0 (intercept)
        betha_0 = self.mean_yi - np.sum(betha_1 * self.mean_xi)

        return betha_0

    def residual_sum_square(self):
        """
        Calculate the residual sum of squares (RSS) of the linear regression model.

        Paramters:
        ---------
        None

        Returns:
        --------
            avg_rss : float
        Residual sum of squares.
        """
        betha_0 = self.intercept()
        betha_1 = self.coefficient()

        # Calculate RSS
        rss = 0
        for feature in self.predictor.columns:
            for xi, yi in zip(self.predictor[feature].values, self.target.values):
                rss += (yi - betha_0 - (betha_1[self.predictor.columns.get_loc(feature)] * xi)) ** 2

        # Sum of all RSS values
        total_rss = np.sum(rss)

        # Calculate the average RSS
        avg_rss = total_rss / len(self.target)

        return avg_rss

    def predict(self, new_data):
        """
        Predict the target variable for new data points.

        Paramters:
        ----------
        new_data : DataFrame
          New data points for prediction.

        Returns:
        --------
        predictions : list
          Predicted target values.
        """
        predictions = []

        # Iterate through each data point in the new_data
        for i in range(len(new_data)):

            prediction = self.intercept()  # Initialize prediction with intercept (betha_0)

            # Iterate through each feature and calculate contribution to prediction
            for j, feature in enumerate(self.predictor.columns):

                # Multiply the coefficient (betha_1) with the value of the feature in the new_data
                prediction += self.betha_1_list[j] * new_data.iloc[i, j]

            predictions.append(prediction)  # Append the prediction for the current data point

        return predictions

    def metrics_regression(self, predicted_labels):
        """
        Calculate the mean_squared_error, root_mean_squared_error,
        mean_absolute_error, and r2 score of the KNN regression model.

        Parameters:
        -----------
        predicted_labels : array-like
            Predicted values by the model.

        Returns:
        --------
        mean_squared_error : float
            Mean squared error between true target values and predicted values.

        root_mean_squared_error : float
            Root mean squared error between true target values and predicted values.

        mean_absolute_error : float
            Mean absolute error between true target values and predicted values.

        r2 : float
            R-squared score (coefficient of determination) of the model.
            R-squared score provides a measure of how well the predictions approximate the true values.
            It ranges from 0 to 1, with 1 indicating perfect predictions.
        """
        # Calculate mean_squared_error
        mean_squared_error = np.mean((target - predicted_labels) ** 2)

        # Calculate root_mean_squared_error
        root_mean_squared_error = np.sqrt(mean_squared_error)

        # Calculate mean_absolute_error
        mean_absolute_error = np.mean(np.abs(target - predicted_labels))

        # Calculate R2
        total_variation = np.sum((target - np.mean(target)) ** 2)
        residual_variation = np.sum((target - predicted_labels) ** 2)
        r2 = 1 - (residual_variation / total_variation)

        return mean_squared_error, root_mean_squared_error, mean_absolute_error, r2
